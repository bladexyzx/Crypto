#import "../src/export.typ": gost, title-templates, enum-numbering, appendixes

#set enum(numbering: enum-numbering)

#show: gost.with(
  title-template: title-templates.hse-university-lab,
  performers: (
    (name: "Мельников В.К.", position: "Студент БИБ252"),
  ),
  about: "О практической работе №1",
  subject: "Подстановочные шифры",
  agreed-by: (
    name: "О.О. Евсютин",
    position: "Заведующий кафедрой информационной безопасности киберфизических систем
канд. техн. наук, доцент",
    year: 2026
  ),
  city: "Москва",
  indent: 1.25cm,
  text-size: (default: 12pt, small: 12pt),
    margin: (
    left: 30mm,
    right: 15mm,
    top: 20mm,
    bottom: 20mm,
  )
)

#outline()

= Задание на практическую работу

Цель данной работы заключается в освоении навыков программной реализации и криптоанализа простых подстановочных шифров.

В рамках практической работы необходимо выполнить следующее:

#list(
  [Написать программную реализацию аффинного шифра, аффинного рекуррентного шифра, а также же шифра простой подстановки.],
  [Изучить методы криптоанализа моноалфавитных шифров, а так же провести криптоанализ данных шифров.],
  [Подготовить отчёт о проделанной работе.]
)

= Краткая теоретическая часть

== Описание шифров

_Шифр простой замены_ --- простейший пример подстановочного шифра, в котором каждому символу открытого текста соответствует один символ зашифрованного текста. Сообщение рассматривается как последовательность символов алфавита A, мощности m, а ключ k формируется как произвольная перестановка алфавита. 

$ k = mat(
  x_1, x_2, dots, x_m;
  y_1, y_2, dots, y_m
) $

В данном случае $x_1, x_2, ... x_m$ --- это символы открытого текста, а $y_1, y_2, ... y_m$ --- символы зашифрованного текста.

Зашифрование осуществляется заменой каждого символа открытого текста на соответствующий ему символ зашифрованного текста и может быть записано как 
$ E_k (x) = (k(x_1), dots, k(x_m)) $ 

Расшифрование осуществляется обратной заменой и может быть записано как
$ D_k (y) = (k^(-1)(y_1), dots, k^(-1)(y_m)), $ 


$ k^(-1) = mat(
  y_1, y_2, dots, y_m;
  x_1, x_2, dots, x_m
) $

_Аффинный шифр_ --- это частный случай шифра замены, который использует математическую функцию для преобразования символов, называемую аффинное преобразование. 

Данный шифр реализует замену символов открытого текста с использованием операций в арифметике остатков. Символы алфавита A мощностью m представляются элементами множества $Z_m$, а ключ $k$ состоит из двух чисел $a$ и $b$, принадлежащих $Z_m$, таких что $a$ и $m$ взаимно простые.

Ключ может быть представлен как перестановка (1), в котором

$ y_i = (a dot x_i + b) (mod m) , i in {1, 2, dots, m} $

Расшифрование осуществляется с помощью обратного аффинного преобразования, которое может быть записано как

$ x_i = (a^(-1) dot (y_i - b)) (mod m), i in {1, 2, dots, m} $

_Аффинный рекуррентный шифр_ --- это усиление аффинного шифра, который использует рекуррентные функции для генерации ключей.

Алгоритм шифрования основан на вычислении нового ключа для каждого символа открытого текста на основе предыдущих символов и ключей. Для этого необходимо задать два ключевые пары: $k_1$ = $(a_1, b_1)$ и $k_2$ = $(a_2, b_2)$, а последующие ключевые пары будут вычисляться по формуле:

$ k_i = ((a_(i-1) dot a_(i-2) )(mod m), (b_(i-1) + b_(i-2)) (mod m), i in {3, 4, dots, m} $

Алгоритм зашифрования, расшифрования и формулы для вычисления ключей аналогично аффинному шифру, но с использованием рекуррентных ключей.
== Методы криптоанализа шифров

_Криптоанализ шифра простой замены._ Для каждого алфавита мощности $m$ может быть подобрано $m!$ различных ключей, что делает полный перебор ключей неэффективным и нецелесообразным. Однако, шифр простой замены является моноалфавитным шифром, что означает, что каждый символ открытого текста всегда заменяется одним и тем же символом зашифрованного текста. Это делает его уязвимым к частотному анализу, который заключается в изучении частоты появления символов в зашифрованном тексте и сопоставлении их с частотой появления символов в языке, на котором написан открытый текст. Например, в русском языке буква "о" встречается чаще всего, следовательно, символ, который встречается чаще всего в зашифрованном тексте, вероятно, соответствует букве "о". Аналогично, можно сопоставить другие часто встречающиеся символы с наиболее частыми буквами в языке.

_Криптоанализ аффинного шифра._ Для каждого алфавита мощности $m$ необходимо подобрать два числа $a$ и $b$, где $gcd(a, m) = 1$, а $b in {0, 1, dots, m-1}$ Чтобы найти количество взаимно простых чисел можно воспользоваться функцией Эйлера $phi(m)$, которая определяет количество чисел от $1$ до $m-1$, которые являются взаимно простыми с $m$. 

$ phi(n) = n product_(p|n) (1 - 1/p), quad n > 1 $
где $p$ --- простое число и пробегает все значения, участвующие в разложении $n$ на простые множители 

Так, для русского алфавита мощности $33 = 3^1 dot 11^1$
$ phi(33) = 33 dot (1 - 1/3) dot (1 - 1/11) = 20 $
В таком случае количество всех возможных ключей равно $33 dot 20 = 660$. Такое количество различных ключей позволяет сделать полный перебор, все современные компьютеры способы выполнить его меньше чем за секунду. Однако, существуют и другие способы криптоанализа. Аффинный шифр является моноалфавитным шифром, что делает его уязвимым к частотному анализу, аналогично шифру простой замены.

_Криптоанализ аффинного рекуррентного шифра._ Аффинный рекуррентный шифр является более сложным, чем аффинный шифр, из-за использования рекуррентных ключей, что делает его полиалфавитным шифром, а следовательно, более устойчивым к частотному анализу. Так, разные символы открытого текста могут быть зашифрованы одними и теми же символами зашифрованного текста и наоборот, что затрудняет использование частотного анализа. 

Разберем сложность полного перебора. Для этого нужно верно подобрать четыре числа: $a_1$, $b_1$, $a_2$ и $b_2$. Числа $a_1$ и $a_2$ должны быть взаимно простыми с мощностью алфавита $m$, а числа $b_1$ и $b_2$ могут принимать любые значения от $0$ до $m-1$. Таким образом, количество возможных ключей равно $phi(m)^2 dot m^2$. Для русского алфавита это будет равно $20^2 dot 33^2 = 435600$. Такое количество ключей делает полный перебор сложным, но не невозможным для современных компьютеров.
= Примеры шифрования

#image("/assets/image.png")
#align(center)[
Рисунок 1 --- Пример шифрования и расшифрования текста с помощью шифра простой замены
]

#image("/assets/image-1.png")
#align(center)[
Рисунок 2 --- Пример шифрования и расшифрования текста с помощью аффинного шифра
]

#image("/assets/image-2.png")
#align(center)[
Рисунок 3 --- Пример шифрования и расшифрования текста с помощью аффинного рекуррентного шифра
]

На этом примере (см. Рисунок 3) видно, что только аффинный рекуррентный шифр обеспечивает шифрование разных символов открытого текста в одни и те же символы зашифрованного текста, что делает его более устойчивым к частотному анализу.

= Программная реализация шифров

Программная реализация шифров была выполнена на языке Python. Реализованы функции записи шифротекста или расшифрованного текста в отдельный файл (см. Рисунок 4), а так же исключение для ошибки записи файла. Написана функция вычисления НОД для двух чисел (см. Рисунок 5) для проверки валидности ключа.

Реализовано 6 функций для расшифровки и шифровки текста тремя способами: простой замены, аффинного шифра и аффинного рекуррентного шифра. Каждая функция принимает на вход открытый текст, ключ и алфавит, а возвращает зашифрованный текст или расшифрованный текст в зависимости от функции. Учтены некоторые исключения, такие как несоответствие мощности алфавита и некорректный ключ (см. Рисунки 6,7,8,9).

Пользователь из консоли может выбрать способ шифрования, ввести открытый текст, ключ и алфавит, а также указать имя файла для сохранения результата. Результат будет записан в указанный файл, в случае если файл с таким именем существует, он будет перезаписан (см. Рисунки 10, 11).

#image("/assets/image-3.png")
#align(center)[
Рисунок 4 --- Реализация функции записи в файл и ее исключения
]

#image("/assets/image-4.png")
#align(center)[
Рисунок 5 --- Реализация функции вычисления НОД
]

#image("/assets/image-5.png")
#align(center)[
Рисунок 6 --- Реализация функций шифрования и расшифрования текста с помощью шифра простой замены
]

#image("/assets/image-6.png")
#align(center)[
Рисунок 7 --- Реализация функций шифрования и расшифрования текста с помощью аффинного шифра
]

#image("/assets/image-7.png")
#align(center)[
Рисунок 8 --- Реализация функции шифрования текста с помощью аффинного рекуррентного шифра
]

#image("/assets/image-8.png")
#align(center)[
Рисунок 9 --- Реализация функции расшифрования текста с помощью аффинного рекуррентного шифра
]

#image("/assets/image-9.png")
#align(center)[
Рисунок 10 --- Реализация главной функции, которая позволяет пользователю выбрать способ шифрования или расшифрования, ввести открытый текст, ключ и алфавит, а также указать имя файла для сохранения результата [часть 1]
]

#image("/assets/image-10.png")
#align(center)[
Рисунок 11 --- Реализация главной функции, которая позволяет пользователю выбрать способ шифрования или расшифрования, ввести открытый текст, ключ и алфавит, а также указать имя файла для сохранения результата [часть 2]
]

#image("/assets/image-16.png")
#align(center)[
Рисунок 12 --- Пример работы программы
]
= Примеры криптоанализа

_Пример криптоанализа шифра простой замены._ Из-за вычислительной сложности полного перебора, наиболее эффективным методом криптоанализа шифра простой замены является частотный анализ. Этот метод позволяет сопоставить наиболее часто встречающиеся символы в зашифрованном тексте с наиболее частыми буквами в языке, на котором написан открытый текст. Для этого нужно определить какие буквы в естественном языке встречаются часто, а какие нет. Можно использовать внешние источники информации, но можно и проанализировать большой объем текста на исходном языке. Для этого я взял первый том "Войны и мир" Л.Н. Толстого [1] и проанализировал частоту появления каждой буквы, французский текст переведен на русский.

Я использовал Jyputer Notebook для анализа текста и построения гистограммы частоты появления каждой буквы. Для подсчета букв в тексте я использовал регулярные выражения и класс Counter из модуля collections, который создает мультимножество, в котором одинаковые символы могут встречаться несколько раз. Для построения гистограммы использовал библиотеку Matplotlib (см. Рисунок 12). 


#image("/assets/image-11.png")
#align(center)[
Рисунок 13 --- Импорт необходимых модулей
]

Далее был разработан алгоритм подсчета количества каждой буквы в тексте и их процентное соотношение относительно всех букв.
#image("/assets/image-12.png")
#align(center)[
Рисунок 14 --- Алгоритм подсчета количества каждой буквы в тексте
]

#image("/assets/image-13.png")
#align(center)[
Рисунок 15 --- Результат алгоритма подсчета количества каждой буквы в тексте
]

Подобный вывод достаточно неудобен для анализа, поэтому я построил гистограмму, которая наглядно показывает частоту появления каждой буквы (см. Рисунок 16).
#image("/assets/image-14.png")
#align(center)[
Рисунок 16 --- Код для гистограммы
]

#image("/assets/image-15.png")
#align(center)[
Рисунок 17 --- Гистограмма частоты появления каждой буквы в тексте    
]

На гистограмме (см. Рисунок 17) видно, что наиболее часто встречающиеся буквы в тексте --- это "о", "е", "а", "и", "н", "т". Поэтому, если в зашифрованном тексте есть символ, который встречается чаще всего, то он вероятно соответствует букве "о". Аналогично, можно сопоставить другие часто встречающиеся символы с наиболее частыми буквами в языке.

= Выводы о проделанной работе

Краткие выводы о проделанной работе: достоинства и недостатки исследуемых шифров, ограничения выбранных методов криптоанализа, наиболее эффективные сценарии криптоанализа.

#bibliography("references.bib")

#show: appendixes

= Формулы
Чтобы оформить формулы в документе, можно использовать синтаксис typst-math. Пример такого использования:

$ sum_(k=0)^n k = 1 + ... + n = (n(n+1)) / 2 $ <appendix-formula>

Как оформлять таблицы сказано в приложении @appendix-tables.

== Таблицы <appendix-tables>
Для создания таблиц используется функция `table()`, обёрнутая в макрос `#figure` для добавления подписи. Пример показан
на таблице @appendix-table.

#figure(
  table(
    columns: 4,
    table.header([Заголовок 1], [Заголовок 2], [Заголовок 3], [Заголовок 4]),
    [Проверка], [Проверка], [Проверка], [Проверка],
    [Проверка], [Проверка], [Проверка], [Проверка],
  ),
  caption: [Пример таблицы с данными],
) <appendix-table>
